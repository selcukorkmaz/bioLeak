% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/audit.R
\name{audit_leakage}
\alias{audit_leakage}
\title{Audit leakage and confounding}
\usage{
audit_leakage(
  fit,
  metric = c("auc", "pr_auc", "rmse", "cindex"),
  B = 1000,
  perm_stratify = TRUE,
  time_block = c("circular", "stationary"),
  block_len = NULL,
  include_z = TRUE,
  ci_method = c("if", "bootstrap"),
  boot_B = 400,
  parallel = FALSE,
  seed = 1,
  return_perm = TRUE,
  batch_cols = NULL,
  coldata = NULL,
  X_ref = NULL,
  target_scan = TRUE,
  target_threshold = 0.9,
  feature_space = c("raw", "rank"),
  sim_method = c("cosine", "pearson"),
  sim_threshold = 0.995,
  nn_k = 50,
  max_pairs = 5000,
  learner = NULL
)
}
\arguments{
\item{fit}{LeakFit}

\item{metric}{performance metric ("auc","pr_auc","rmse","cindex")}

\item{B}{integer, number of permutations}

\item{perm_stratify}{logical, stratify permutation by class within fold (binomial)}

\item{time_block}{block resampling method for time-series modes}

\item{block_len}{integer block length (NULL for automatic)}

\item{include_z}{logical, whether to compute IF-based z-score for Δ}

\item{ci_method}{"if" or "bootstrap" for Δ confidence interval}

\item{boot_B}{bootstrap resamples when ci_method = "bootstrap"}

\item{parallel}{logical, use future.apply for permutations}

\item{seed}{integer random seed}

\item{return_perm}{logical, store permutation distribution}

\item{batch_cols}{character vector of metadata columns to test association with folds}

\item{coldata}{optional data.frame of sample-level metadata (rows align to original samples)}

\item{X_ref}{optional numeric matrix/data.frame (samples x features) used for duplicate detection
and target leakage scan}

\item{target_scan}{logical, compute feature-wise outcome associations to flag proxy columns}

\item{target_threshold}{numeric in (0,1), score threshold for flagging proxy features}

\item{feature_space}{"raw" or "rank" (rank-normalize rows before similarity)}

\item{sim_method}{"cosine" or "pearson"}

\item{sim_threshold}{numeric in (0,1), similarity threshold for duplicates (default 0.995)}

\item{nn_k}{integer, if RANN available and n large, #nearest neighbors per row to check (default 50)}

\item{max_pairs}{cap on the number of duplicate pairs returned (default 5000)}

\item{learner}{optional learner name to audit when multiple learners are present}
}
\value{
LeakAudit
}
\description{
Audit leakage and confounding
}
\details{
Duplicate detection uses the selected \code{sim_method}:
cosine similarity on L2-normalized rows, or Pearson similarity by row-centering
before normalization. Use \code{feature_space = "rank"} to compare rank profiles.
Target leakage scan computes feature-wise associations with the outcome and
flags proxy columns based on the scaled association score.
}
\examples{
\dontrun{
set.seed(1)
df <- data.frame(
  subject = rep(1:20, each = 2),
  outcome = rbinom(40, 1, 0.5),
  x1 = rnorm(40),
  x2 = rnorm(40)
)
splits <- make_splits(df, outcome = "outcome",
                      mode = "subject_grouped", group = "subject", v = 5)
fit <- fit_resample(df, outcome = "outcome", splits = splits,
                    learner = "glmnet", metrics = "auc")
audit <- audit_leakage(fit, metric = "auc", B = 50, X_ref = df[, c("x1", "x2")])
summary(audit)
}
}
