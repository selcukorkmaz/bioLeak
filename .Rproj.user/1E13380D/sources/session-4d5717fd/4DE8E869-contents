# 1. Minimal Example: Train/Test Split with Leak Detection

library(bioLeak)

set.seed(1)
x1 <- rnorm(100)
x2 <- rnorm(100)
y  <- rbinom(100, 1, plogis(0.5*x1 - 0.7*x2))
X  <- data.frame(x1, x2, y)


splits <- make_splits(X, outcome = "y", mode = "subject_grouped", v = 5, stratify = TRUE)
splits


fit <- fit_resample(
  x = X,
  outcome = "y",
  splits = splits,
  learner = "glmnet",
  learner_args = list(alpha = 1),
  metrics = c("auc", "accuracy"),
  parallel = FALSE
)

audit <- audit_leakage(fit)


summary(audit)


# 2. Intermediate Example: Guarded Imputation + Audit

library(bioLeak)

# simulate missing data
set.seed(123)

n <- 200

# Gerçek bağımsız değişkenler
x1 <- rnorm(n, mean = 0, sd = 1)
x2 <- rnorm(n, mean = 0, sd = 1)
x3 <- rnorm(n, mean = 0, sd = 1)  # gürültü değişkeni

# Gerçek ilişki: logit(p) = -0.5 + 1.2*x1 - 0.8*x2
eta <- -0.5 + 1.2*x1 - 0.8*x2
p <- 1 / (1 + exp(-eta))
y <- rbinom(n, 1, p)

# Veri çerçevesi oluştur
X <- data.frame(x1, x2, x3, y)

# Rastgele bazı eksik değerler ekle
X[sample(1:n, 20), "x2"] <- NA
X[sample(1:n, 30), "x3"] <- NA

# İnceleme
summary(X)
cor(X, use = "pairwise.complete.obs")
table(y)


splits <- make_splits(X, outcome = "y", mode = "subject_grouped", v = 5, stratify = TRUE)

library(doParallel)
cl <- makeCluster(2)  # işlemci çekirdek sayına göre ayarla
registerDoParallel(cl)

# use leakage-safe robust imputation
imp <- impute_guarded(
  train = X[1:100, -4],
  test  = X[101:200, -4],
  method = "missForest",
  winsor = TRUE,
  parallel = TRUE
)

stopCluster(cl)


# Fit model using imputed data
fit <- fit_resample(
  x = X,
  outcome = "y",
  splits = splits,
  learner = "glmnet",
  learner_args = list(alpha = 1),
  metrics = c("auc", "accuracy"),
  preprocess = list(
    impute = list(method = "missForest"),  # eksik veri için robust imputasyon
    normalize = list(method = "zscore"),   # z-score standardizasyon
    filter = list(var_thresh = 0, iqr_thresh = 0),
    fs = list(method = "none"),            # feature selection yok
    winsor = TRUE                          # aykırı değerleri Winsorize et
  ),
  parallel = FALSE
)


# Audit for permutation gap & duplicates
audit <- audit_leakage(
  fit,
  n_perm = 30,
  X_ref = X[, -4],         # özellik matrisi (y hariç)
  sim_threshold = 0.995,   # near-duplicate detection threshold
  feature_space = "raw"    # veya "rank"
)
summary(audit)



# 3. Advanced Example: Full Workflow with KNN, Nested CV, and Audit Trail

library(bioLeak)

set.seed(42)

# -------------------------------------------------------------------------
# 1. Simulate batch-structured biomedical data
# -------------------------------------------------------------------------
n <- 150
X <- data.frame(
  age = rnorm(n, 50, 10),
  biomarker1 = rnorm(n),
  biomarker2 = rnorm(n),
  batch = rep(paste0("Center", 1:5), each = 30),
  y = rbinom(n, 1, 0.5)
)

# -------------------------------------------------------------------------
# 2. Create leakage-safe nested cross-validation splits
# -------------------------------------------------------------------------
splits <- make_splits(
  x = X,
  outcome = "y",
  mode = "batch_blocked",
  batch = "batch",
  v = 5,
  repeats = 1,
  stratify = TRUE,
  nested = TRUE,      # inner CV inside each outer training set
  seed = 42
)

# A short summary is automatically printed
splits@mode
splits@indices
splits@info


# -------------------------------------------------------------------------
# 3. Fit KNN classifier with leakage-guarded preprocessing
# -------------------------------------------------------------------------
fit <- fit_resample(
  x = X,
  outcome = "y",
  splits = splits,
  learner = "ranger",
  learner_args = list(num.trees = 300, mtry = 2),
  preprocess = list(
    impute = list(method = "knn"),
    normalize = list(method = "zscore"),
    filter = list(var_thresh = 0, iqr_thresh = 0),
    fs = list(method = "none"),
    winsor = TRUE
  ),
  metrics = c("auc", "accuracy"),
  parallel = TRUE,
  refit = TRUE
)
